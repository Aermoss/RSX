const float ONE_THIRD = 1.0f / 3.0f;
const float ONE_SIXTH = 1.0f / 6.0f;
const float TWO_THIRD = 2.0f / 3.0f;

float[] rgb_to_yiq(float r, float g, float b) {
    return {
        y = 0.30f * r + 0.59f * g + 0.11f * b,
        i = 0.74f * (r - y) - 0.27f * (b - y),
        q = 0.48f * (r - y) + 0.41f * (b - y)
    };
}

float[] yiq_to_rgb(float y, float i, float q) {
    // float r = y + (0.27f * q + 0.41f * i) / (0.74f * 0.41f + 0.27f * 0.48f);
    // float b = y + (0.74f * q - 0.48f * i) / (0.74f * 0.41f + 0.27f * 0.48f);
    // float g = y - (0.30f * (r - y) + 0.11f * (b - y)) / 0.59f;

    float r = y + 0.9468822170900693f * i + 0.6235565819861433f * q;
    float g = y - 0.27478764629897834f * i - 0.6356910791873801f * q;
    float b = y - 1.1085450346420322f * i + 1.7090069284064666f * q;

    if (r < 0.0f) r = 0.0f;
    if (g < 0.0f) g = 0.0f;
    if (b < 0.0f) b = 0.0f;
    if (r > 1.0f) r = 1.0f;
    if (g > 1.0f) g = 1.0f;
    if (b > 1.0f) b = 1.0f;

    return {r, g, b};
}

float _v(float m1, float m2, float hue) {
    hue = hue % 1.0f;
    if (hue < ONE_SIXTH) return m1 + (m2 - m1) * hue * 6.0f;
    if (hue < 0.5f) return m2;
    if (hue < TWO_THIRD) return m1 + (m2 - m1) * (TWO_THIRD - hue) * 6.0f;
    return m1;
}

float[] rgb_to_hls(float r, float g, float b) {
    float maxc = max({r, g, b});
    float minc = min({r, g, b});
    float sumc = (maxc + minc)
    float rangec = (maxc - minc)
    float l = sumc / 2.0f;
    float s;

    if (minc == maxc) return {0.0f, l, 0.0f}
    if (l <= 0.5f) s = rangec / sumc
    else s = rangec / (2.0f - sumc);

    float rc = (maxc - r) / rangec;
    float gc = (maxc - g) / rangec;
    float bc = (maxc - b) / rangec;
    float h = 0.0f;

    if (r == maxc) h = bc - gc;
    else if (g == maxc) h = 2.0f + rc - bc;
    else h = 4.0f + gc - rc;

    h = (h / 6.0f) % 1.0f;
    return {h, l, s};
}

float[] hls_to_rgb(float h, float l, float s) {
    if (s == 0.0f) return {l, l, l};
    if (l <= 0.5f) m2 = l * (1.0f + s);
    else m2 = l + s - (l * s);
    m1 = 2.0f * l - m2;
    return {_v(m1, m2, h + ONE_THIRD), _v(m1, m2, h), _v(m1, m2, h - ONE_THIRD)};
}

float[] rgb_to_hsv(float r, float g, float b) {
    float maxc = max({r, g, b});
    float minc = min({r, g, b});
    float v = maxc;

    if (minc == maxc) return {0.0f, 0.0f, v};
    float s = (maxc - minc) / maxc;
    float rc = (maxc - r) / (maxc - minc);
    float gc = (maxc - g) / (maxc - minc);
    float bc = (maxc - b) / (maxc - minc);
    float h = 0.0f;

    if (r == maxc) h = bc - gc;
    else if (g == maxc) h = 2.0f + rc - bc;
    else h = 4.0f + gc - rc;

    h = (h / 6.0f) % 1.0f;
    return {h, s, v};
}

float[] hsv_to_rgb(float h, float s, float v) {
    if (s == 0.0f) return {v, v, v};
    int i = h * 6.0f;
    float f = (h * 6.0f) - i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));
    i = i % 6;

    if (i == 0) return {v, t, p};
    if (i == 1) return {q, v, p};
    if (i == 2) return {p, v, t};
    if (i == 3) return {p, q, v};
    if (i == 4) return {t, p, v};
    if (i == 5) return {v, p, q};
}